{
  "model_name": "qwen2.5-coder:3b",
  "model_type": "code",
  "timestamp": 1757435406,
  "problems_tested": 2,
  "template_results": {
    "direct": {
      "pass_at_k": {
        "1": 0.0,
        "5": 0.0,
        "10": 0.0,
        "100": 0.0
      },
      "confidence_intervals": {
        "1": [
          0.0,
          0.0
        ],
        "5": [
          0.0,
          0.0
        ],
        "10": [
          0.0,
          0.0
        ],
        "100": [
          0.0,
          0.0
        ]
      },
      "success_rate": 0.0,
      "total_samples": 6,
      "generations": [
        {
          "problem_id": "HumanEval/0",
          "template": "direct",
          "attempt": 0,
          "generated_code": "To solve the problem of checking if any two numbers in a list are closer to each other than a given threshold, we can use a simple approach that involves iterating through the list and comparing each pair of numbers with the threshold. Here's how you can implement this:",
          "execution_time": 10.433660745620728,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/0",
          "template": "direct",
          "attempt": 1,
          "generated_code": "To solve the problem of checking if any two numbers in a list are closer to each other than a given threshold, we can use a simple approach that involves sorting the list and then comparing adjacent elements. Here's how you can implement this:",
          "execution_time": 0.9967203140258789,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/0",
          "template": "direct",
          "attempt": 2,
          "generated_code": "To solve the problem of checking if any two numbers in a list are closer to each other than a given threshold, we can use a simple approach that involves sorting the list and then comparing adjacent elements. Here's how you can implement this:",
          "execution_time": 0.9830021858215332,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "direct",
          "attempt": 0,
          "generated_code": "To solve this problem, we need to parse the input string and identify groups of nested parentheses. Each group should be balanced and separated from others. Here's a step-by-step approach to achieve this:",
          "execution_time": 1.157217264175415,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "direct",
          "attempt": 1,
          "generated_code": "To solve this problem, we need to parse the input string and identify groups of nested parentheses. Each group should be balanced and separated from others. Here's a step-by-step approach to achieve this:",
          "execution_time": 0.8343515396118164,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "direct",
          "attempt": 2,
          "generated_code": "To solve this problem, we need to parse the input string and identify groups of nested parentheses. Each group should be balanced and separated from others. Here's a step-by-step approach to achieve this:",
          "execution_time": 0.840770959854126,
          "success": false,
          "error_message": null
        }
      ]
    },
    "instruction": {
      "pass_at_k": {
        "1": 0.33333333333333337,
        "5": 0.8683127572016461,
        "10": 0.3333333333333333,
        "100": 0.3333333333333333
      },
      "confidence_intervals": {
        "1": [
          0.0,
          0.6666666666666667
        ],
        "5": [
          0.0,
          0.9958847736625515
        ],
        "10": [
          0.0,
          0.6666666666666666
        ],
        "100": [
          0.0,
          0.6666666666666666
        ]
      },
      "success_rate": 0.3333333333333333,
      "total_samples": 6,
      "generations": [
        {
          "problem_id": "HumanEval/0",
          "template": "instruction",
          "attempt": 0,
          "generated_code": "To complete the function `has_close_elements`, we need to iterate through the list of numbers and check if any two consecutive numbers are closer to each other than the given threshold. Here's how you can implement this:",
          "execution_time": 1.3071486949920654,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/0",
          "template": "instruction",
          "attempt": 1,
          "generated_code": "To complete the function `has_close_elements`, we need to iterate through the list of numbers and check if any two consecutive numbers are closer to each other than the given threshold. If such a pair is found, the function should return `True`; otherwise, it should return `False`.",
          "execution_time": 1.1746890544891357,
          "success": true,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/0",
          "template": "instruction",
          "attempt": 2,
          "generated_code": "To complete the function `has_close_elements`, we need to iterate through the list of numbers and check if any two consecutive numbers are closer to each other than the given threshold. If such a pair is found, the function should return `True`; otherwise, it should return `False`.",
          "execution_time": 1.1579811573028564,
          "success": true,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "instruction",
          "attempt": 0,
          "generated_code": "To complete the `separate_paren_groups` function, we need to parse the input string and identify groups of nested parentheses. Each group should be balanced and separated from others. Here's how you can implement this:",
          "execution_time": 1.2245674133300781,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "instruction",
          "attempt": 1,
          "generated_code": "To complete the `separate_paren_groups` function, we need to parse the input string and extract balanced groups of parentheses. We can achieve this by iterating through the string and using a stack to keep track of the opening parentheses. When we encounter a closing parenthesis, we pop from the stack until we find the corresponding opening parenthesis, which indicates the end of a group. Here's how you can implement this:",
          "execution_time": 1.638397216796875,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "instruction",
          "attempt": 2,
          "generated_code": "To solve this problem, we need to parse the input string and identify groups of nested parentheses. Each group should be balanced and separated by spaces in the output list. Here's how you can implement the `separate_paren_groups` function:",
          "execution_time": 1.021507978439331,
          "success": false,
          "error_message": null
        }
      ]
    },
    "few_shot": {
      "pass_at_k": {
        "1": 0.0,
        "5": 0.0,
        "10": 0.0,
        "100": 0.0
      },
      "confidence_intervals": {
        "1": [
          0.0,
          0.0
        ],
        "5": [
          0.0,
          0.0
        ],
        "10": [
          0.0,
          0.0
        ],
        "100": [
          0.0,
          0.0
        ]
      },
      "success_rate": 0.0,
      "total_samples": 6,
      "generations": [
        {
          "problem_id": "HumanEval/0",
          "template": "few_shot",
          "attempt": 0,
          "generated_code": "```python\nfrom typing import List",
          "execution_time": 0.5887994766235352,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/0",
          "template": "few_shot",
          "attempt": 1,
          "generated_code": "```python",
          "execution_time": 0.15845465660095215,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/0",
          "template": "few_shot",
          "attempt": 2,
          "generated_code": "```python\nfrom typing import List",
          "execution_time": 0.24265408515930176,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "few_shot",
          "attempt": 0,
          "generated_code": "```python\nfrom typing import List",
          "execution_time": 0.5480244159698486,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "few_shot",
          "attempt": 1,
          "generated_code": "```python\nfrom typing import List",
          "execution_time": 0.24683451652526855,
          "success": false,
          "error_message": null
        },
        {
          "problem_id": "HumanEval/1",
          "template": "few_shot",
          "attempt": 2,
          "generated_code": "```python\nfrom typing import List",
          "execution_time": 0.24683403968811035,
          "success": false,
          "error_message": null
        }
      ]
    }
  },
  "pass_at_k": {
    "1": 0.5,
    "5": 0.5,
    "10": 0.5,
    "100": 0.5
  },
  "statistical_metrics": {
    "mean_score": 0.1111111111111111,
    "std_dev": 0.19245008972987523,
    "min_score": 0.0,
    "max_score": 0.3333333333333333,
    "sensitivity": 0.3333333333333333,
    "template_scores": {
      "direct": 0.0,
      "instruction": 0.3333333333333333,
      "few_shot": 0.0
    }
  },
  "metadata": {
    "templates_used": [
      "direct",
      "instruction",
      "few_shot"
    ],
    "samples_per_template": 3,
    "k_values": [
      1,
      5,
      10,
      100
    ],
    "random_seed": 42,
    "confidence_level": 0.95
  }
}